<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Moto Esquivando Obstáculos</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid #000;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuración del juego
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const laneWidth = canvasWidth / 3;
        const playerWidth = 40;
        const playerHeight = 60;
        const obstacleWidth = 40;
        const obstacleHeight = 60;
        const playerY = canvasHeight - playerHeight - 20; // Posición fija en Y
        let playerX = (canvasWidth / 2) - (playerWidth / 2); // Posición inicial en X
        const playerSpeed = 5;
        const baseObstacleSpeed = 3;
        const invulnerabilityTime = 3000; // 3 segundos en ms

        let obstacles = [];
        let score = 0;
        let gameOver = false;
        let keys = {};
        let invulnerable = false;
        let invulnerabilityEndTime = 0;
        let spawnInterval = 2000; // Inicial, en ms
        let spawnTimer;

        // Tipos de obstáculos
        const obstacleTypes = [
            { color: 'red', speed: baseObstacleSpeed, behavior: 'straight' }, // Rojo: recto
            { color: 'green', speed: baseObstacleSpeed, behavior: 'deviate' }, // Verde: se desvía
            { color: 'yellow', speed: baseObstacleSpeed * 1.2, behavior: 'straight' } // Amarillo: más rápido
        ];

        // Manejo de teclas
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && !invulnerable) { // Espacio para invulnerabilidad
                invulnerable = true;
                invulnerabilityEndTime = Date.now() + invulnerabilityTime;
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Función para spawn de obstáculos
        function spawnObstacle() {
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            const lane = Math.floor(Math.random() * 3);
            const x = lane * laneWidth + (laneWidth / 2) - (obstacleWidth / 2);
            obstacles.push({
                x: x,
                y: -obstacleHeight,
                ...type,
                deviated: false // Para verdes
            });

            // Aumentar frecuencia de spawn con el tiempo
            spawnInterval = Math.max(500, spawnInterval - 50); // Mínimo 500ms
            clearTimeout(spawnTimer);
            spawnTimer = setTimeout(spawnObstacle, spawnInterval);
        }

        // Actualizar juego
        function update() {
            if (gameOver) return;

            // Mover jugador
            if (keys['ArrowLeft'] && playerX > 0) {
                playerX -= playerSpeed;
            }
            if (keys['ArrowRight'] && playerX + playerWidth < canvasWidth) {
                playerX += playerSpeed;
            }

            // Actualizar invulnerabilidad
            if (invulnerable && Date.now() > invulnerabilityEndTime) {
                invulnerable = false;
            }

            // Mover obstáculos
            obstacles.forEach((obs, index) => {
                obs.y += obs.speed;

                // Comportamiento de desviación para verdes
                if (obs.behavior === 'deviate' && !obs.deviated && obs.y > canvasHeight / 2) {
                    obs.deviated = true;
                    // Desviarse hacia el jugador
                    const direction = playerX > obs.x ? 1 : -1;
                    obs.x += direction * (Math.random() * 50 + 50); // Desvío aleatorio pero significativo
                    // Asegurar que no salga de la pantalla
                    obs.x = Math.max(0, Math.min(canvasWidth - obstacleWidth, obs.x));
                }

                // Eliminar si sale de la pantalla
                if (obs.y > canvasHeight) {
                    obstacles.splice(index, 1);
                    score++;
                }

                // Chequear colisión si no invulnerable
                if (!invulnerable && checkCollision(playerX, playerY, playerWidth, playerHeight, obs.x, obs.y, obstacleWidth, obstacleHeight)) {
                    gameOver = true;
                }
            });

            draw();
            requestAnimationFrame(update);
        }

        // Dibujar
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Dibujar carriles decorativos
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(laneWidth, 0);
            ctx.lineTo(laneWidth, canvasHeight);
            ctx.moveTo(laneWidth * 2, 0);
            ctx.lineTo(laneWidth * 2, canvasHeight);
            ctx.stroke();

            // Dibujar jugador (moto)
            ctx.fillStyle = 'blue';
            ctx.globalAlpha = invulnerable ? 0.5 : 1; // Semi-transparente si invulnerable
            ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
            ctx.globalAlpha = 1;

            // Dibujar obstáculos (autos)
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.color;
                ctx.fillRect(obs.x, obs.y, obstacleWidth, obstacleHeight);
            });

            // Dibujar score
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Puntuación: ${score}`, 10, 30);

            if (gameOver) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.fillText('Game Over', canvasWidth / 2 - 100, canvasHeight / 2);
            }
        }

        // Chequear colisión
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
        }

        // Iniciar juego
        spawnTimer = setTimeout(spawnObstacle, spawnInterval);
        update();
    </script>
</body>
</html>
